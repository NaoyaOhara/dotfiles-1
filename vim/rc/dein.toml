# basic {{{
[[plugins]]
repo = 'Konfekt/FastFold'

[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'
if = '''! (has('macunix') && has('kaoriya') && isdirectory(expand('$VIM/plugins/vimproc')))'''
hook_post_update = 'call delphinus#init#vimproc#hook_post_update()'

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''"{{{
let s:cuicolors = {
      \ 'base03': [ '8', '234', 'DarkGray' ],
      \ 'base02': [ '0', '235', 'Black' ],
      \ 'base01': [ '10', '239', 'LightGreen' ],
      \ 'base00': [ '11', '240', 'LightYellow' ],
      \ 'base0':  [ '12', '244', 'LightBlue' ],
      \ 'base1':  [ '14', '245', 'LightCyan' ],
      \ 'base2': [ '7', '187', 'LightGray' ],
      \ 'base3': [ '15', '230', 'White' ],
      \ 'yellow': [ '3', '136', 'DarkYellow' ],
      \ 'orange': [ '9', '166', 'LightRed' ],
      \ 'red': [ '1', '124', 'DarkRed' ],
      \ 'magenta': [ '5', '125', 'DarkMagenta' ],
      \ 'violet': [ '13', '61', 'LightMagenta' ],
      \ 'blue': [ '4', '33', 'DarkBlue' ],
      \ 'cyan': [ '6', '37', 'DarkCyan' ],
      \ 'green': [ '2', '64', 'DarkGreen' ],
      \ }

" The following condition only applies for the console and is the same
" condition vim-colors-solarized uses to determine which set of colors
" to use.
let s:solarized_termcolors = get(g:, 'solarized_termcolors', 256)
if s:solarized_termcolors != 256 && &t_Co >= 16
  let s:cuiindex = 0
elseif s:solarized_termcolors == 256
  let s:cuiindex = 1
else
  let s:cuiindex = 2
endif

let s:base03 = [ '#002b36', s:cuicolors.base03[s:cuiindex] ]
let s:base02 = [ '#073642', s:cuicolors.base02[s:cuiindex] ]
let s:base01 = [ '#586e75', s:cuicolors.base01[s:cuiindex] ]
let s:base00 = [ '#657b83', s:cuicolors.base00[s:cuiindex] ]
let s:base0 = [ '#839496', s:cuicolors.base0[s:cuiindex] ]
let s:base1 = [ '#93a1a1', s:cuicolors.base1[s:cuiindex] ]
let s:base2 = [ '#eee8d5', s:cuicolors.base2[s:cuiindex] ]
let s:base3 = [ '#fdf6e3', s:cuicolors.base3[s:cuiindex] ]
let s:yellow = [ '#b58900', s:cuicolors.yellow[s:cuiindex] ]
let s:orange = [ '#cb4b16', s:cuicolors.orange[s:cuiindex] ]
let s:red = [ '#dc322f', s:cuicolors.red[s:cuiindex] ]
let s:magenta = [ '#d33682', s:cuicolors.magenta[s:cuiindex] ]
let s:violet = [ '#6c71c4', s:cuicolors.violet[s:cuiindex] ]
let s:blue = [ '#268bd2', s:cuicolors.blue[s:cuiindex] ]
let s:cyan = [ '#2aa198', s:cuicolors.cyan[s:cuiindex] ]
let s:green = [ '#859900', s:cuicolors.green[s:cuiindex] ]

let s:bold = 'bold'

if &background ==# 'light'
  let [ s:base03, s:base3 ] = [ s:base3, s:base03 ]
  let [ s:base02, s:base2 ] = [ s:base2, s:base02 ]
  let [ s:base01, s:base1 ] = [ s:base1, s:base01 ]
  let [ s:base00, s:base0 ] = [ s:base0, s:base00 ]
endif

let s:normal = [ [ s:base03, s:base1, s:bold ], [ s:base03, s:base0 ], [ s:base3, s:base02 ] ]

" http://paletton.com/#uid=13C0u0kw0w0jyC+oRxVy4oIDfjr
let s:insert = [
        \ [ s:blue, s:base2, s:bold ],
        \ [ s:base03, [ '#5e8ebd', 67 ] ],
        \ [ s:base03, [ '#3169ac', 61 ] ],
        \ [ s:base2, [ '#0e53a7', 25 ] ],
        \ [ s:base03, [ '#0e53a7', 25 ] ],
        \ [ s:base2, [ '#0a4081', 24 ] ] ]
" http://paletton.com/#uid=1090u0kw0w0jyC+oRxVy4oIDfjr
let s:replace = [
        \ [ s:red, s:base2, s:bold ],
        \ [ s:base03, [ '#ff8e63', 209 ] ],
        \ [ s:base03, [ '#ff5f39', 203 ] ],
        \ [ s:base2, [ '#ff3100', 202 ] ],
        \ [ s:base03, [ '#ff5f39', 203 ] ],
        \ [ s:base2, [ '#c52600', 160 ] ] ]
" http://paletton.com/#uid=14Q0u0kw0w0jyC+oRxVy4oIDfjr
let s:visual = [
        \ [ s:magenta, s:base2, s:bold ],
        \ [ s:base03, [ '#aa4dbe', 133 ] ],
        \ [ s:base03, [ '#962aad', 92 ] ],
        \ [ s:base2, [ '#8c04a8', 91 ] ],
        \ [ s:base03, [ '#962aad', 92 ] ],
        \ [ s:base2, [ '#6c0382', 54 ] ] ]

let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}

let s:p.normal.left     = [ [ s:base03, s:green, s:bold ] ] + s:normal
let s:p.inactive.left   = [ [ s:base0, s:base02 ], [ s:base0, s:base02 ] ]
let s:p.insert.left     = s:insert[0:3]
let s:p.replace.left    = s:replace[0:3]
let s:p.visual.left     = s:visual[0:3]

let s:p.normal.right    = [ [ s:base03, s:base1 ], [ s:base03, s:base00 ] ]
let s:p.inactive.right  = [ [ s:base03, s:base00 ], [ s:base0, s:base02 ] ]
let s:p.insert.right    = s:insert[1:2] + s:insert[4:4]
let s:p.replace.right   = s:replace[1:2] + s:replace[4:4]
let s:p.visual.right    = s:visual[1:2] + s:visual[4:4]

let s:p.normal.middle   = [ [ s:base1, s:base02 ] ]
let s:p.inactive.middle = [ [ s:base01, s:base02 ] ]
let s:p.insert.middle   = s:insert[5:5]
let s:p.replace.middle  = s:replace[5:5]
let s:p.visual.middle   = s:visual[5:5]

let s:p.tabline.left    = [ [ s:base03, s:base00 ] ]
let s:p.tabline.tabsel  = [ [ s:base03, s:base1 ] ]
let s:p.tabline.middle  = [ [ s:base0, s:base02 ] ]
let s:p.tabline.right   = copy(s:p.normal.right)

let s:p.normal.error    = [ [ s:base03, s:red ] ]
let s:p.insert.error    = s:insert[5:5]
let s:p.replace.error   = s:replace[5:5]
let s:p.visual.error    = s:visual[5:5]
let s:p.normal.warning  = [ [ s:base03, s:yellow ] ]
let s:p.insert.warning  = s:insert[5:5]
let s:p.replace.warning = s:replace[5:5]
let s:p.visual.warning  = s:visual[5:5]
let s:p.normal.ok       = [ [ s:green, s:base02 ] ]
let s:p.insert.ok       = s:insert[5:5]
let s:p.replace.ok      = s:replace[5:5]
let s:p.visual.ok       = s:visual[5:5]

let g:lightline#colorscheme#solarized_custom#palette = lightline#colorscheme#flatten(s:p)

let g:lightline = {
        \ 'colorscheme': 'solarized_custom',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ], [ 'fugitive' ], [ 'filepath' ], [ 'filename' ] ],
        \   'right': [
        \     [ 'lineinfo' ],
        \     [ 'percent' ],
        \     [ 'ale', 'ale_ok' ],
        \     [ 'char_code', 'fileformat', 'fileencoding', 'filetype' ],
        \   ],
        \ },
        \ 'component_function': {
        \   'modified': 'LightLineModified',
        \   'readonly': 'LightLineReadonly',
        \   'fugitive': 'LightLineFugitive',
        \   'filepath': 'LightLineFilePath',
        \   'filename': 'LightLineFilename',
        \   'fileformat': 'LightLineFileformat',
        \   'filetype': 'LightLineFiletype',
        \   'fileencoding': 'LightLineFileencoding',
        \   'mode': 'LightLineMode',
        \   'char_code': 'LightLineCharCode',
        \ },
        \ 'component_function_visible_condition': {
        \   'mode': 1,
        \ },
        \ 'component_expand': {
        \   'ale': 'LightLineALE',
        \   'ale_ok': 'LightLineALEOK',
        \ },
        \ 'component_type': {
        \   'ale': 'error',
        \   'ale_ok': 'ok',
        \ },
        \ 'separator': { 'left': '', 'right': '' },
        \ 'subseparator': { 'left': '', 'right': '' },
        \ }

function! LightLineModified()
  return &filetype =~# 'help\|vimfiler\|gundo' ? '' :
        \ &modified ? '' : &modifiable ? '' :
        \ '-'
endfunction

function! LightLineReadonly()
  return &filetype ==# 'help' ? '' :
        \ &filetype !~# 'vimfiler\|gundo' && &readonly ? '' :
        \ ''
endfunction

function! LightLineFilePath()
  let l:ro_string = '' !=# LightLineReadonly() ? LightLineReadonly() . ' ' : ''
  if &filetype ==# 'vimfilter' || &filetype ==# 'unite' || winwidth(0) < 70
    let l:path_string = ''
  else
    let l:path_string = substitute(expand('%:h'), $HOME, '~', '')
    if winwidth(0) < 120 && len(l:path_string) > 30
      let l:path_string = substitute(l:path_string, '\v([^/])[^/]*%(/)@=', '\1', 'g')
    endif
  endif

  return l:ro_string . l:path_string
endfunction

function! LightLineFilename()
  return (&filetype ==# 'vimfiler' ? vimfiler#get_status_string() :
        \  &filetype ==# 'unite' ? unite#get_status_string() :
        \ '' !=# expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' !=# LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFugitive()
  if winwidth(0) < 100
    return ''
  endif
  try
    if &filetype !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 120 ? &fileformat . (exists('*WebDevIconsGetFileFormatSymbol') ? ' ' . WebDevIconsGetFileFormatSymbol() : '') : ''
endfunction

function! LightLineFiletype()
  return winwidth(0) > 120 ? (strlen(&filetype) ? &filetype . (exists('*WebDevIconsGetFileTypeSymbol') ? ' ' . WebDevIconsGetFileTypeSymbol() : '') : 'no ft') : ''
endfunction

function! LightLineFileencoding()
  return winwidth(0) > 120 ? (strlen(&fileencoding) ? &fileencoding : &encoding) : ''
endfunction

function! LightLineMode()
  let l:fname = expand('%:t')
  return l:fname =~# 'unite' ? 'Unite' :
        \ l:fname =~# 'vimfiler' ? 'VimFilter' :
        \ l:fname =~# '__Gundo__' ? 'Gundo' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! LightLineCharCode()
  if winwidth(0) <= 120
    return ''
  endif
  redir => l:tmp | silent! ascii | redir END
  let l:m = matchlist(l:tmp, '<\(.\+\)>\s*\(\d\+\)')
  return len(l:m) > 0 ? printf('%s %X', l:m[1], l:m[2]) : ''
endfunction

function! LightLineALEOKString()
  let l:formats = get(g:, 'ale_statusline_format', [])
  return get(l:formats, 2, '')
endfunction

let g:LightLineALECache = {}

function! LightLineALEString(mode)
  let l:ok = LightLineALEOKString()
  if l:ok ==# ''
    return ''
  endif
  let l:buf = bufname('')
  if get(g:LightLineALECache, l:buf, '') ==# ''
    let g:LightLineALECache[l:buf] = ale#statusline#Status()
  endif
  if a:mode == 1
    if g:LightLineALECache[l:buf] ==# l:ok
      return g:LightLineALECache[l:buf]
    endif
  else
    if g:LightLineALECache[l:buf] !=# l:ok
      return g:LightLineALECache[l:buf]
    endif
  endif
  return ''
endfunction

function! LightLineALE()
  return LightLineALEString(0)
endfunction

function! LightLineALEOK()
  return LightLineALEString(1)
endfunction

function! LightLineALEUpdate()
  let g:LightLineALECache[bufname('')] = ''
  call lightline#update()
endfunction

augroup LightLineOnALE
  autocmd!
  autocmd User ALELint call LightLineALEUpdate()
augroup END
"}}}'''

[[plugins]]
repo     = 'kana/vim-submode'
hook_add = '''"{{{
  call submode#enter_with('DWM_size', 'n', '', '<C-w>>', ':call DWM_GrowMaster()<CR>')
  call submode#enter_with('DWM_size', 'n', '', '<C-w><', ':call DWM_ShrinkMaster()<CR>')
  call submode#map('DWM_size', 'n', '', '>', ':call DWM_GrowMaster()<CR>')
  call submode#map('DWM_size', 'n', '', '<', ':call DWM_ShrinkMaster()<CR>')
"}}}'''

[[plugins]]
repo     = 'ryanoasis/vim-devicons'
hook_add = '''"{{{
  let g:webdevicons_enable_unite = 0
  let g:webdevicons_enable_nerdtree = 0
  let g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol = ''
  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols = {
        \ 'fcgi':     '',
        \ 'perl':     '',
        \ 'sqlite':   '',
        \ 'tt':       '',
        \ 'txt':      '',
        \ }
"}}}'''

[[plugins]]
repo     = 'tmux-plugins/vim-tmux-focus-events'
if       = '''exists('$TMUX') || ! has('gui_running')'''
hook_add = 'set autoread'

[[plugins]]
repo     = 'tpope/vim-fugitive'
hook_add = '''"{{{
  let g:fugitive_git_executable = expand('HOME=$H git my-alias')
  nnoremap git :<c-u>Git
  nnoremap g<space> :<c-u>Git 
  nnoremap d< :diffget //2<CR>
  nnoremap d> :diffget //3<CR>
"}}}'''

[[plugins]]
repo = 'tpope/vim-repeat'

[[plugins]]
repo = 'vim-jp/vimdoc-ja'

[[plugins]]
repo     = 'w0rp/ale'
on_event = ['FocusLost', 'CursorHold']
hook_add = '''
  let a:ale_echo_msg_format = '%severity%: %linter%: %s'
  let g:ale_sign_column_always = 1
  let g:ale_sign_error = ' '
  let g:ale_sign_warning = ' '
  let g:ale_statusline_format = ['  %d', '  %d', '  ']
  let g:ale_linters = {
        \ 'go': [ 'gofmt', 'go vet', 'golint' ],
        \ }
'''
# }}}

# colorscheme {{{
[[plugins]]
repo     = 'delphinus/vim-colors-solarized'
rev      = 'for-hydrozen-fork'
hook_add = 'let g:solarized_menu = 0'

[[plugins]]
repo     = 'lifepillar/vim-solarized8'
on_if    = '''has('termguicolors')'''
hook_add = '''
  let g:solarized_diffmode = 'normal'
  let g:solarized_visibility = 'normal'
  if $TERM =~# 'italic'
    let g:solarized_term_italics = 1
  endif

  nnoremap  <leader>B :<c-u>exe "colors" (g:colors_name =~# "dark"
      \ ? substitute(g:colors_name, 'dark', 'light', '')
      \ : substitute(g:colors_name, 'light', 'dark', '')
      \ )<cr>
'''
# }}}

# syntax {{{
[[plugins]]
repo = 'ChrisYip/Better-CSS-Syntax-for-Vim'

[[plugins]]
repo = 'Glench/Vim-Jinja2-Syntax'

[[plugins]]
repo = 'aklt/plantuml-syntax'

[[plugins]]
repo = 'cespare/vim-toml'

[[plugins]]
repo   = 'leafgarland/typescript-vim'
merged = 0

[[plugins]]
repo     = 'delphinus/vim-markdown'
rev      = 'merged-inline_and_code_fixes-conceal'
hook_add = '''"{{{
  augroup SetMarkdown
    autocmd!
    autocmd FileType markdown,howm_memo.markdown setlocal conceallevel=2
    autocmd FileType markdown,howm_memo.markdown hi markdownH1 cterm=bold,italic gui=bold,italic
    autocmd FileType markdown,howm_memo.markdown hi markdownH2 cterm=bold gui=bold
    autocmd FileType markdown,howm_memo.markdown hi markdownH3 cterm=italic gui=italic
  augroup END

  let g:markdown_fenced_languages = [
        \ 'coffee',
        \ 'cpp',
        \ 'css',
        \ 'diff',
        \ 'erlang',
        \ 'go',
        \ 'haskell',
        \ 'html',
        \ 'java',
        \ 'javascript',
        \ 'json',
        \ 'lua',
        \ 'ocaml',
        \ 'perl',
        \ 'plantuml',
        \ 'python',
        \ 'ruby',
        \ 'sh',
        \ 'sql',
        \ 'toml',
        \ 'typescript',
        \ 'vim',
        \ 'xml',
        \ ]
  " set conceal feature: default value '#*dlaibBces'
  let g:markdown_conceal = '*dlaibBes'
"}}}'''

[[plugins]]
repo = 'digitaltoad/vim-jade'

[[plugins]]
repo = 'kchmck/vim-coffee-script'

[[plugins]]
repo     = 'elzr/vim-json'
if       = '''! has('kaoriya')'''
hook_add = 'let g:vim_json_syntax_conceal = 0'

[[plugins]]
repo = 'motemen/xslate-vim'

[[plugins]]
repo = 'moznion/vim-cpanfile'

[[plugins]]
repo = 'othree/html5.vim'

[[plugins]]
repo = 'othree/javascript-libraries-syntax.vim'

[[plugins]]
repo = 'othree/yajs.vim'

[[plugins]]
repo = 'vim-perl/vim-perl'
# }}}

# filetype {{{
[[plugins]]
repo = 'ap/vim-css-color'

[[plugins]]
repo = 'c9s/perlomni.vim'

[[plugins]]
repo = 'delphinus/vim-rails'
rev  = 'feature/recognize-ridgepole'

[[plugins]]
repo = 'jason0x43/vim-js-indent'

[[plugins]]
repo  = 'pearofducks/ansible-vim'

[[plugins]]
repo = 'taskwarrior/task'
rtp  = 'scripts/vim'

[[plugins]]
repo  = 'ternjs/tern_for_vim'
build = 'npm install'

[[plugins]]
repo = 'tmux-plugins/vim-tmux'
# }}}

# for unite {{{
[[plugins]]
repo      = 'Shougo/unite-outline'

[[plugins]]
repo      = 'Kocha/vim-unite-tig'

[[plugins]]
repo      = 'basyura/unite-rails'

[[plugins]]
repo      = 'lambdalisue/vim-gista-unite'
hook_post_source = '''
  call unite#custom#default_action('gista', 'narrow')
'''

[[plugins]]
repo      = 'pekepeke/vim-unite-z'

[[plugins]]
repo      = 'sorah/unite-bundler'

[[plugins]]
repo      = 'tsukkee/unite-tag'

[[plugins]]
repo     = 'ujihisa/neco-look'
hook_add = '''"{{{
  let g:neocomplete#text_mode_filetypes = {
        \ 'rst': 1,
        \ 'markdown': 1,
        \ 'howm_memo': 1,
        \ 'howm_memo.markdown': 1,
        \ 'gitrebase': 1,
        \ 'gitcommit': 1,
        \ 'vcs-commit': 1,
        \ 'hybrid': 1,
        \ 'text': 1,
        \ 'help': 1,
        \ 'tex': 1,
        \ }
"}}}'''
# }}}

# vim-script {{{
[[plugins]]
repo = 'HiColors'

[[plugins]]
repo = 'applescript.vim'

[[plugins]]
repo = 'ingo-library'

[[plugins]]
repo = 'nginx.vim'
# }}}

# dependencies {{{
[[plugins]]
repo = 'kana/vim-textobj-user'
# }}}

# vim:se fdm=marker:
